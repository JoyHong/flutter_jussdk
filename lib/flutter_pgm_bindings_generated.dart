// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/include/*.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen_pgm.yaml`.
///
class FlutterMtcBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FlutterMtcBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FlutterMtcBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  void pgm_c_version(
    ffi.Pointer<ffi.Char> pcVersion,
  ) {
    return _pgm_c_version(
      pcVersion,
    );
  }

  late final _pgm_c_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'pgm_c_version');
  late final _pgm_c_version =
      _pgm_c_versionPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// 设置回调函数, 进程拉起即可调用, 生存期内只需调用一次
  void pgm_c_init(
    PGM_C_EVENT_PROCESSOR eventProcessorCb,
    PGM_C_LOAD_GROUP loadGroupCb,
    PGM_C_UPDATE_GROUP updateGroupCb,
    PGM_C_UPDATE_STATUSES updateStatusesCb,
    PGM_C_UPDATE_RPOPS updatePropsCb,
    PGM_C_INSERT_MSGS insertMsgsCb,
    PGM_C_GET_TICKS getTicksCb,
  ) {
    return _pgm_c_init(
      eventProcessorCb,
      loadGroupCb,
      updateGroupCb,
      updateStatusesCb,
      updatePropsCb,
      insertMsgsCb,
      getTicksCb,
    );
  }

  late final _pgm_c_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              PGM_C_EVENT_PROCESSOR,
              PGM_C_LOAD_GROUP,
              PGM_C_UPDATE_GROUP,
              PGM_C_UPDATE_STATUSES,
              PGM_C_UPDATE_RPOPS,
              PGM_C_INSERT_MSGS,
              PGM_C_GET_TICKS)>>('pgm_c_init');
  late final _pgm_c_init = _pgm_c_initPtr.asFunction<
      void Function(
          PGM_C_EVENT_PROCESSOR,
          PGM_C_LOAD_GROUP,
          PGM_C_UPDATE_GROUP,
          PGM_C_UPDATE_STATUSES,
          PGM_C_UPDATE_RPOPS,
          PGM_C_INSERT_MSGS,
          PGM_C_GET_TICKS)>();

  /// 控制库的内部参数, 暂时未用
  int pgm_c_set_cfgs(
    ffi.Pointer<JStrStrMap> pcCfgs,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_set_cfgs(
      pcCfgs,
      pcErr,
    );
  }

  late final _pgm_c_set_cfgsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_set_cfgs');
  late final _pgm_c_set_cfgs = _pgm_c_set_cfgsPtr.asFunction<
      int Function(ffi.Pointer<JStrStrMap>, ffi.Pointer<ffi.Char>)>();

  /// 1. 在sdk的login succ回调之后调用, pgm_logined以下声明的函数, 都必须晚于pgm_logined调用
  /// 2. logout再login succ后需重新调用
  /// 3. MtcCliReconnectOkNotification回调无需调用
  int pgm_c_logined(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_logined(
      pcCookie,
      pcErr,
    );
  }

  late final _pgm_c_loginedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('pgm_c_logined');
  late final _pgm_c_logined = _pgm_c_loginedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int pgm_c_get_cur_time(
    ffi.Pointer<ffi.Int64> plCurTimeMs,
  ) {
    return _pgm_c_get_cur_time(
      plCurTimeMs,
    );
  }

  late final _pgm_c_get_cur_timePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int64>)>>(
          'pgm_c_get_cur_time');
  late final _pgm_c_get_cur_time =
      _pgm_c_get_cur_timePtr.asFunction<int Function(ffi.Pointer<ffi.Int64>)>();

  /// 异常实时上报
  /// SELF_USER_ID RECORD_TIME内部自动添加, 不需要传入
  int pgm_c_record_err(
    ffi.Pointer<JStrStrMap> pcErrRecord,
  ) {
    return _pgm_c_record_err(
      pcErrRecord,
    );
  }

  late final _pgm_c_record_errPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<JStrStrMap>)>>(
          'pgm_c_record_err');
  late final _pgm_c_record_err =
      _pgm_c_record_errPtr.asFunction<int Function(ffi.Pointer<JStrStrMap>)>();

  /// flush db异常恢复后, 调用pgm_flush_all清空待写队列
  int pgm_c_flush_data(
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_flush_data(
      pcErr,
    );
  }

  late final _pgm_c_flush_dataPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'pgm_c_flush_data');
  late final _pgm_c_flush_data =
      _pgm_c_flush_dataPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// 以下接口当cookie重复/请求过频/未登录/入参本地检查有误时返回false. rpc的异步结果通过CookieEnd事件回调
  int pgm_c_refresh_main(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_refresh_main(
      pcCookie,
      pcErr,
    );
  }

  late final _pgm_c_refresh_mainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_refresh_main');
  late final _pgm_c_refresh_main = _pgm_c_refresh_mainPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// 1. 调用时会追加检查orgId是否是存在于自己的个人列表中, 不存在会直接报错
  /// 2. 如若刷新的同时刚好被踢出组织/另一台登录设备退出组织, 请求发出的同时本地还未更新到该变化, 将通过CookieEnd回调permission-denied:not_in_group
  /// 除此之外, cookieEnd只会回调succ
  int pgm_c_refresh_org(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcOrgId,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_refresh_org(
      pcCookie,
      pcOrgId,
      pcErr,
    );
  }

  late final _pgm_c_refresh_orgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_refresh_org');
  late final _pgm_c_refresh_org = _pgm_c_refresh_orgPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// 1. 无需对方确认的列表修改
  /// 2. 调用方式:
  /// a. 好友(批量)添加: pgm_add_relations(cookie, selfUid, map<uid,Relation(Contact,tagName,tag,nullCfgs)>, err)
  /// b. 直接入群: pgm_add_relations(cookie, selfUid, map<orgId,Relation(Organize,tagName,tag,nullCfgs)>, err), added map size必须为1
  /// c. 拉人入群: pgm_add_relations(cookie, orgId, map<uid,Relation(Member,tagName,tag,nullCfgs)>, err)
  /// 3. CookieEnd 'added_exist'时,表示同时间点发生了异源修改,比如 自己两台正在登录的设备, 同时添加同一个人
  /// 接口保证 会先将这样的列表异源修改flush db, 再回调CookieEnd err!
  int pgm_c_add_relations(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<JRelationsMap> pcAdded,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_add_relations(
      pcCookie,
      pcGroupId,
      pcAdded,
      pcErr,
    );
  }

  late final _pgm_c_add_relationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelationsMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_add_relations');
  late final _pgm_c_add_relations = _pgm_c_add_relationsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<JRelationsMap>, ffi.Pointer<ffi.Char>)>();

  /// 1. 调用方式: @groupId是节点所属的列表id, @changed是修改节点id及内容的集合. 比如
  /// a. 设置组织消息免打扰: pgm_change_relations(cookie, orgId, map<selfUid,Relation(preType,preTagName,preTag,preCfgs['ImPush']='0'>, err)
  /// 2. 需要将修改节点修改后的全部内容传入. 故目前存在这样的问题: 2个异源修改同时分别修改不同字段时, 最终可能只有一条生效
  /// 3. CookieEnd 'changed_nonexist'时, 表示同时间点发生了异源修改, 比如 修改自己的群内备注名时刚好群主把自己踢了
  /// 接口保证 会先将这样的他源列表修改flush db, 再回调CookieEnd err!
  int pgm_c_change_relations(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<JRelationsMap> pcChanged,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_change_relations(
      pcCookie,
      pcGroupId,
      pcChanged,
      pcErr,
    );
  }

  late final _pgm_c_change_relationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelationsMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_change_relations');
  late final _pgm_c_change_relations = _pgm_c_change_relationsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<JRelationsMap>, ffi.Pointer<ffi.Char>)>();

  /// 1. 即时生效修改. 不等待后端确认. 若后端修改失败, 库内部保证最终重试成功
  /// 2. 只能是修改, 不能是增删, 且一次只能修改一个节点
  /// 3. 尽量只用该接口修改只与显示相关的次要元素, 若用来修改组织消息免打扰,当rpc最终成功前, 可能导致ui效果与实际效果不一致的问题
  /// 4. 调用方式: @groupId是节点所属列表id, @changedId是节点id, changedRel是修改后的节点完整内容
  int pgm_c_nowait_ack_change_relation(
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<ffi.Char> pcChangedId,
    ffi.Pointer<JRelation> pcChangedRel,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_nowait_ack_change_relation(
      pcGroupId,
      pcChangedId,
      pcChangedRel,
      pcErr,
    );
  }

  late final _pgm_c_nowait_ack_change_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelation>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_nowait_ack_change_relation');
  late final _pgm_c_nowait_ack_change_relation =
      _pgm_c_nowait_ack_change_relationPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelation>, ffi.Pointer<ffi.Char>)>();

  /// 1. 调用方式:
  /// a. 退群: pgm_remove_relations(cookie, selfUid, set<orgId>, err), removed set size必为1
  /// b. 踢群: pgm_remove_relations(cookie, orgId, set<uid>, err)
  /// c. 删除好友尽量不使用pgm_remove_relations, 而改用pgm_change_relations(Stranger)形式实现
  /// 2. 'removed_nonexist'有两种可能
  /// a. 异源修改. 退群时刚好群主把自己踢了的异源修改 或 两台设备同时退一个群
  /// b. rpc发生了单通+重传. 首次调用写成功但response丢失, 导致自动重传, 重传时判定'removed_nonexist'
  /// 目前接口自己无法区分这两种情况. 但上层大部分情况下能够依靠前后短时间内有无Group.Update通知来判定(异源修改都会有通知, 只要网络是通畅的)
  int pgm_c_remove_relations(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<JStrSet> pcRemoved,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_remove_relations(
      pcCookie,
      pcGroupId,
      pcRemoved,
      pcErr,
    );
  }

  late final _pgm_c_remove_relationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JStrSet>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_remove_relations');
  late final _pgm_c_remove_relations = _pgm_c_remove_relationsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<JStrSet>, ffi.Pointer<ffi.Char>)>();

  /// 查询自己在对方列表中的身份级别. CookieEnd value为String(Group::RelationType), 比如13表示Contact,15表示Strange. 其他非整数值表示失败reason
  int pgm_c_check_relation(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcPeerUid,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_check_relation(
      pcCookie,
      pcPeerUid,
      pcErr,
    );
  }

  late final _pgm_c_check_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_check_relation');
  late final _pgm_c_check_relation = _pgm_c_check_relationPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// 1. 调用方式:
  /// a. 好友申请: A pgm_apply_relation(cookie, uidB, selfUid, Friend, 'A wanna be B friend', syncRelation, notifyParams, err)
  /// @syncRelation为获同意后, A 个人列表uidB的同步added节点. 若申请前uidB已在A个人列表中, syncRelation填Relation(NoneSyncType,"","",nullCfgs)
  /// b. 组织邀请: A pgm_apply_relation(cookie, uidB, orgIdC, Organize, 'A invite B as C member', syncRelation, notifyParams, err)
  /// @syncRelation为获同意后, 组织列表C中 uidB的同步added节点
  /// c. 组织申请: A pgm_apply_relation(cookie, orgIdC, uidAOrB, Member, 'A apply AOrB as C member', syncRelation, notifyParams, err)
  /// @syncRelation为获同意后, AOrB 个人列表 orgIdC的同步added节点
  /// 2. 调用成功后,所有相关方都将回调P2PApply/OrgApply/OrgInvite event
  int pgm_c_apply_relation(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<ffi.Char> pcTargetId,
    int iTargetType,
    ffi.Pointer<ffi.Char> pcDesc,
    ffi.Pointer<JRelation> pcSyncRelation,
    ffi.Pointer<JStrStrMap> pcInParams,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_apply_relation(
      pcCookie,
      pcGroupId,
      pcTargetId,
      iTargetType,
      pcDesc,
      pcSyncRelation,
      pcInParams,
      pcErr,
    );
  }

  late final _pgm_c_apply_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelation>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_apply_relation');
  late final _pgm_c_apply_relation = _pgm_c_apply_relationPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<JRelation>,
          ffi.Pointer<JStrStrMap>,
          ffi.Pointer<ffi.Char>)>();

  /// 1. 调用方式:
  /// a. 好友申请: B pgm_accept_relation(cookie, msgIdx, tagNameA, tagA, nullCfgs, notifyParams, err). 若只想使用A的昵称作为备注名,昵称可通过apply的@desc传入, 下同
  /// b. 组织邀请: B pgm_accept_relation(cookie, msgIdx, tagNameC, tagC, nullCfgs, notifyParams, err)
  /// c. 组织申请: C Owner/任一Manager pgm_accept_relation(cookie, msgIdx, tagNameAOrB, tagAOrB, nullCfgs, notifyParams, err)
  /// 2. 调用成功后,所有相关方都将回调P2PApplyResponse/OrgApplyResponse/OrgInviteResponse event
  int pgm_c_accept_relation(
    ffi.Pointer<ffi.Char> pcCookie,
    int lMsgIdx,
    ffi.Pointer<ffi.Char> pcTargetTagName,
    ffi.Pointer<ffi.Char> pcTargetTag,
    ffi.Pointer<JStrStrMap> pcTargetCfgs,
    ffi.Pointer<JStrStrMap> pcInParams,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_accept_relation(
      pcCookie,
      lMsgIdx,
      pcTargetTagName,
      pcTargetTag,
      pcTargetCfgs,
      pcInParams,
      pcErr,
    );
  }

  late final _pgm_c_accept_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int64,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_accept_relation');
  late final _pgm_c_accept_relation = _pgm_c_accept_relationPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<JStrStrMap>,
          ffi.Pointer<JStrStrMap>,
          ffi.Pointer<ffi.Char>)>();

  /// @relations为初始成员, 必须包含自己作为Owner
  /// @orgProps群属性
  int pgm_c_create_org(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<JRelationsMap> pcRelations,
    ffi.Pointer<JStrStrMap> pcOrgProps,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_create_org(
      pcCookie,
      pcRelations,
      pcOrgProps,
      pcErr,
    );
  }

  late final _pgm_c_create_orgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JRelationsMap>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_create_org');
  late final _pgm_c_create_org = _pgm_c_create_orgPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<JRelationsMap>,
          ffi.Pointer<JStrStrMap>, ffi.Pointer<ffi.Char>)>();

  int pgm_c_disband_org(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcOrgId,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_disband_org(
      pcCookie,
      pcOrgId,
      pcErr,
    );
  }

  late final _pgm_c_disband_orgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_disband_org');
  late final _pgm_c_disband_org = _pgm_c_disband_orgPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// 1. 设置对方看到的自己的状态. 比如 A设置 正在编辑 之于B: A pgm_set_status_to_peer(cookie, uidB, 'Editing', '1', err)
  /// 2. @timeStamp为状态版本, 在并发乱序情况下, 状态写只会由低版本更新为高版本
  /// 需要在多个同时登录设备之间维护版本才需要填. 否则一般填-1, 此时pgm库默认使用粗校后的本地时间作为状态版本. pgm_set_org_status同
  int pgm_c_set_status_to_peer(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcPeerUid,
    ffi.Pointer<ffi.Char> pcType,
    ffi.Pointer<ffi.Char> pcValue,
    int lTimeStamp,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_set_status_to_peer(
      pcCookie,
      pcPeerUid,
      pcType,
      pcValue,
      lTimeStamp,
      pcErr,
    );
  }

  late final _pgm_c_set_status_to_peerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int64,
              ffi.Pointer<ffi.Char>)>>('pgm_c_set_status_to_peer');
  late final _pgm_c_set_status_to_peer =
      _pgm_c_set_status_to_peerPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// 1. 设置组织中某节点(可能是自己也可能是他人)的状态. 比如 A设置自己在组织C中的状态为繁忙: A pgm_nowait_ack_set_status(cookie, orgIdC, uidA, 'Busy', '1', err)
  /// 2. 设置self列表中他人的状态, 供其他设备登录时读取. A pgm_nowait_ack_set_status(cookie, uidA, uidB, '...', '1', err), 暂无明确的应用场景
  int pgm_c_nowait_ack_set_status(
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<ffi.Char> pcTargetId,
    ffi.Pointer<ffi.Char> pcType,
    ffi.Pointer<ffi.Char> pcValue,
    int lTimeStamp,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_nowait_ack_set_status(
      pcGroupId,
      pcTargetId,
      pcType,
      pcValue,
      lTimeStamp,
      pcErr,
    );
  }

  late final _pgm_c_nowait_ack_set_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int64,
              ffi.Pointer<ffi.Char>)>>('pgm_c_nowait_ack_set_status');
  late final _pgm_c_nowait_ack_set_status =
      _pgm_c_nowait_ack_set_statusPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// 1. 设置自己/组织属性(会有组织权限检查), @props传diff
  /// 2. 设置成功后将回调PGM_UPDATE_RPOPS
  int pgm_c_nowait_ack_set_props(
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<JStrStrMap> pcDiffProps,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_nowait_ack_set_props(
      pcGroupId,
      pcDiffProps,
      pcErr,
    );
  }

  late final _pgm_c_nowait_ack_set_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_nowait_ack_set_props');
  late final _pgm_c_nowait_ack_set_props =
      _pgm_c_nowait_ack_set_propsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>();

  /// 1. 读取任何人/任何组织的属性, 包括但不限于自己的好友/加入的组织
  /// 2. @prefixs 传希望获取的属性key前缀的集合. 若要获取所有属性, prefixs = [""]即可(空串是所有key的前缀)
  /// 3. 查到的结果将回调PGM_UPDATE_RPOPS
  /// 4. @prefixs若包含'SessionsStatus', 结果集中将包含rslt['SessionsStatus'] = '{sid0:int_status0,sid1:int_status1}'
  /// 0 表示online
  /// 2 表示offline(未注册push模版)
  /// 其他正整数表示offlinePush,正整数的值是offlinePush的毫秒时间戳
  int pgm_c_get_props(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcGroupId,
    ffi.Pointer<JStrSet> pcPrefixs,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_get_props(
      pcCookie,
      pcGroupId,
      pcPrefixs,
      pcErr,
    );
  }

  late final _pgm_c_get_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<JStrSet>, ffi.Pointer<ffi.Char>)>>('pgm_c_get_props');
  late final _pgm_c_get_props = _pgm_c_get_propsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<JStrSet>, ffi.Pointer<ffi.Char>)>();

  /// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  int pgm_c_send_p2p_msg(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcPeerUid,
    ffi.Pointer<JMsgContent> pcContent,
    ffi.Pointer<JStrStrMap> pcInParams,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_c_send_p2p_msg(
      pcCookie,
      pcPeerUid,
      pcContent,
      pcInParams,
      pcErr,
    );
  }

  late final _pgm_c_send_p2p_msgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JMsgContent>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_c_send_p2p_msg');
  late final _pgm_c_send_p2p_msg = _pgm_c_send_p2p_msgPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<JMsgContent>,
          ffi.Pointer<JStrStrMap>,
          ffi.Pointer<ffi.Char>)>();

  /// 1. 在群消息中, MsgContent::_params[Message::K_MSG_REMIND] = "9999_1;9999_2" 表示需要无视这些人在群列表中Relation::cfgs[Group::K_CFG_IM_PUSH]的配置, 发push
  /// 使用它来实现@功能
  int pgm_send_org_msg(
    ffi.Pointer<ffi.Char> pcCookie,
    ffi.Pointer<ffi.Char> pcOrgId,
    ffi.Pointer<JMsgContent> pcContent,
    ffi.Pointer<JStrStrMap> pcInParams,
    ffi.Pointer<ffi.Char> pcErr,
  ) {
    return _pgm_send_org_msg(
      pcCookie,
      pcOrgId,
      pcContent,
      pcInParams,
      pcErr,
    );
  }

  late final _pgm_send_org_msgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<JMsgContent>,
              ffi.Pointer<JStrStrMap>,
              ffi.Pointer<ffi.Char>)>>('pgm_send_org_msg');
  late final _pgm_send_org_msg = _pgm_send_org_msgPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<JMsgContent>,
          ffi.Pointer<JStrStrMap>,
          ffi.Pointer<ffi.Char>)>();
}

typedef PGM_C_EVENT_PROCESSOR = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Int32 event, ffi.Pointer<JStrStrMap> pcParams)>>;

abstract class PGM_EVENT {
  static const int InvalidEvent = 0;

  /// 1. params.size()必为1, key为cookie,value为空表示成功, 为其他值表示失败reason
  /// 2. 唯一的特例是pgm_check_relation. value为String(Group::RelationType), 比如13表示Contact,15表示Strange. 其他非整数值表示失败reason
  static const int CookieEnd = 1;

  /// 组织列表同步,被加/踢时收到
  /// params['Time'] : 事件时间(取自sysMsg::_time)
  /// ['InvokerUid'] : Message::K_MSG_INVOKER_UID
  /// ['InvokerName'] : Message::K_MSG_INVOKER_NAME, 组织内名
  /// ['OrgName'] : Message::K_MSG_ORG_NAME
  /// ['OrgDel'] : value '0'/'1', 有此项且为1表示此事件为被踢,否则为被加
  static const int OrgRelSync = 2;

  /// 好友申请
  /// 申请方收到的事件, 用于维护 发起申请表单:
  /// params['Time'] : 事件时间
  /// ['GroupId'] : Message::K_MSG_APPLY_GROUP_ID, pgm_apply_relation接口入参@groupId, 确认方uid
  /// ['GroupName'] : Message::K_MSG_APPLY_GROUP_NAME, 确认方昵称
  /// ['TargetType'] : Message::K_MSG_APPLY_TARGET_TYPE, 入参@targetType枚举的整数值, 希望获取的权限
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在P2PApplyResponse中
  /// 确认方收到的事件, 用于维护 收到申请表单:
  /// params['Time'] : 事件时间
  /// ['TargetId'] : Message::K_MSG_APPLY_TARGET_ID, 申请方uid
  /// ['TargetName'] : Message::K_MSG_APPLY_TARGET_NAME, 申请方昵称
  /// ['TargetType'] : Message::K_MSG_APPLY_TARGET_TYPE, 入参@targetType枚举的整数值, 希望获取的权限
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在pgm_accept_relation的@msgIdx中, 注意, 双方的msgIdx都只是自身的system msg idx, 往往并不相等, 下同
  static const int P2PApply = 3;

  /// 组织申请
  /// 申请方收到的事件, 用于维护 发起申请表单:
  /// params['Time'] : 事件时间
  /// ['GroupId'] : Message::K_MSG_APPLY_GROUP_ID, pgm_apply_relation接口入参@groupId, orgId
  /// ['GroupName'] : Message::K_MSG_APPLY_GROUP_NAME, orgName
  /// ['TargetId'] : Message::K_MSG_APPLY_TARGET_ID, 只有代申请有此项, 入参@targetId, 此时targetId不是自己
  /// ['TargetName'] : Message::K_MSG_APPLY_TARGET_NAME, 只有代申请有此项
  /// ['TargetType'] : Message::K_MSG_APPLY_TARGET_TYPE, 入参@targetType枚举的整数值, 希望获取的权限
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在OrgApplyResponse中
  /// 确认方收到的事件:
  /// params['Time'] : 事件时间
  /// ['GroupId'] : Message::K_MSG_APPLY_GROUP_ID, pgm_apply_relation接口入参@groupId, orgId
  /// ['GroupName'] : Message::K_MSG_APPLY_GROUP_NAME, orgName
  /// ['TargetId'] : Message::K_MSG_APPLY_TARGET_ID, 入参@targetId
  /// ['TargetName'] : Message::K_MSG_APPLY_TARGET_NAME
  /// ['TargetType'] : Message::K_MSG_APPLY_TARGET_TYPE, 入参@targetType枚举的整数值, 希望获取的权限
  /// ['ApplicantId'] : Message::K_MSG_APPLY_APPLICANT_ID, 只有代申请有此项, 此时applicantId!=targetId
  /// ['ApplicantName'] : Message::K_MSG_APPLY_APPLICANT_NAME, 只有代申请有此项
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在pgm_accept_relation的@msgIdx中
  static const int OrgApply = 4;

  /// 组织邀请
  /// 邀请方收到的事件
  /// params['Time'] : 事件时间
  /// ['GroupId'] : Message::K_MSG_APPLY_GROUP_ID, pgm_apply_relation接口入参@groupId, 确认方uid
  /// ['GroupName'] : Message::K_MSG_APPLY_GROUP_NAME, 确认方昵称
  /// ['TargetId'] : Message::K_MSG_APPLY_TARGET_ID, orgId
  /// ['TargetName'] : Message::K_MSG_APPLY_TARGET_NAME, orgName
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在OrgInviteResponse中
  /// 确认方收到的事件:
  /// params['Time'] : 事件时间
  /// ['TargetId'] : Message::K_MSG_APPLY_TARGET_ID, orgId
  /// ['TargetName'] : Message::K_MSG_APPLY_TARGET_NAME, orgName
  /// ['ApplicantId'] : Message::K_MSG_APPLY_APPLICANT_ID
  /// ['ApplicantName'] : Message::K_MSG_APPLY_APPLICANT_NAME
  /// ['Desc'] : Message::K_MSG_APPLY_DESC, 入参@desc
  /// ['ApplyMsgIdx'] : Message::K_MSG_APPLY_APPLY_MSG_IDX, 将被用在pgm_accept_relation的@msgIdx中
  static const int OrgInvite = 5;

  /// 同对应的Apply(没有'Desc'字段了)
  static const int P2PApplyResponse = 6;
  static const int OrgApplyResponse = 7;
  static const int OrgInviteResponse = 8;
}

typedef JStrStrMap = ffi.Char;

/// 1. 列表尚无本地db缓存时, 容器赋空, relationUpdateTime赋值-1(参见Group::INVALID_UPDATE_TIME), statusTime赋值-1
/// 2. groupId ==selfUid(加载个人列表)时,需要从本地im会话db中还原出'MLV'状态
/// 例如, P2P/9999_1中Message::_msgIdx的最大值(假设为100), 需要在@statusVersMap中如下构造
/// statusVersMap['9999_1']['MLV'] = Status::StatusTime("100",100)
/// 若会话尚无任何消息(确实未发过任何消息/新设备/清理过缓存数据),则无需构造. 群同理
typedef PGM_C_LOAD_GROUP = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char> pcGroupId,
            ffi.Pointer<ffi.Pointer<JRelationsMap>> ppcRelations,
            ffi.Pointer<ffi.Int64> plRelationUpdateTime,
            ffi.Pointer<ffi.Pointer<JStatusVersMap>> ppcStatusVersMap,
            ffi.Pointer<ffi.Int64> plStatusTime,
            ffi.Pointer<ffi.Pointer<JStrStrMap>> ppcProps)>>;
typedef JRelationsMap = ffi.Char;
typedef JStatusVersMap = ffi.Char;

/// 1. statusTime == -1时, 不更新statusTime至本地db. 但若statusVersMap非空, 仍需更新statusVersMap
/// 2. 下述情况下diff可以为空, 此时只更新updateTime, statusVersMap及非-1的statusTime至db即可
/// a. 当仅有的后端版本递进修改被本地'尚未提交'的修改所覆盖时
/// b. 版本有递进但修改前后抵消时, 比如刚被拉入组织又被踢出
/// 3. statusVersMap.size()往往不等于diff.size(). 状态的更新独立于列表, 但又受制于列表: 只当列表内有某节点时, 该节点的状态才有意义
/// 当某节点从列表内删除 (diff[removedId] == Group::Relation()) 时, 其对应状态集也需删除.
typedef PGM_C_UPDATE_GROUP = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char> pcGroupId,
            ffi.Pointer<JRelationsMap> pcDiff,
            ffi.Int64 lUpdateTime,
            ffi.Pointer<JStatusVersMap> pcStatusVersMap,
            ffi.Int64 lStatusTime)>>;

/// 1. im指针的读写通过status实现
/// 2. 有别于列表的离散版本递进, status没有全局版本(每个状态有独立的自身版本), 但有一个更新时的伪全局时间戳. 借助更新时间戳和statusTime来实现status的差异同步
/// 3. 状态写回调是一个upsert写. 例如: 本地db缓存为 9999_1:{'k0':'v0','k1':'v1'} -> PGM_UPDATE_STATUSES(9999_1:{'k0':'v0_','k2':'v2'}) -> 9999_1:{'k0':'v0_','k1':'v1','k2':'v2'}
/// 4. 库内部已判断状态版本, 低版本会被直接丢弃, 不会回调上层
/// 5. statusVersMap为空时, statusTime必不为-1. 此时回调应仅复写statusTime
/// 6. statusVersMap非空时, statusTime可能为-1. 为-1时只需复写statusVersMap
/// 7. 列表节点增加时伴生的状态写, 参见PGM_UPDATE_GROUP
typedef PGM_C_UPDATE_STATUSES = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char> pcGroupId,
            ffi.Pointer<JStatusVersMap> pcStatusVersMap,
            ffi.Int64 lStatusTime)>>;

/// 更新任何人包括自己, 任何组织的属性, upsert写. 可能由几个途径触发:
/// 1. pgm_refresh_main, 更新自己的属性
/// 2. pgm_refresh_org, 更新组织的属性(比如组织名)
/// 3. pgm_nowait_ack_set_props
/// 4. getProps, 更新 好友/群友/搜索,分享等方式找到的陌生人 的属性
/// 5. 异源修改通知, 目前只为自己属性的异设备修改做了通知
typedef PGM_C_UPDATE_RPOPS = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char> pcGroupId, ffi.Pointer<JStrStrMap> pcProps)>>;

/// 1. 3种情况都会触发此回调
/// a. pgm库自动接收未读且未收的消息
/// b. 即时消息通知
/// c. 消息发送成功, 此时这条自己发送的消息也会回调
/// 2. 后端保证只下发该下发的消息, 但由于rpc/通知的时序不确定性, 存在以下极端情况
/// a. A刚拉黑了B, 但仍然回调了来自B的消息
/// i. B发消息, 成功写入云端,发出通知
/// ii. A拉黑B/设B为陌生人, 成功返回,本地列表更新完毕
/// iii. 步骤a的消息通知delay抵达
/// 或者
/// b. A发现B已将账号删除, 但仍然回调了来自B的消息
/// i. B发消息, 成功写入云端, 发出通知
/// ii. B删除账号, 通知到A, 本地列表更新, 删除B节点(由于规定删除好友使用change Stranger实现, 可认为好友节点的删除只会由账号删除触发)
/// iii. 步骤a的消息通知delay抵达
/// 由于B发消息是成功的, 考虑到应使发送/接收端一致, 这条消息通知pgm库不直接吞掉, 而是仍然回调. 上层自行决定如何展示
typedef PGM_C_INSERT_MSGS = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char> pcGroupId,
            ffi.Pointer<JSortedMsgs> pcMsgs,
            ffi.Pointer<JStatusTimes> pcMsgStatuses)>>;
typedef JSortedMsgs = ffi.Char;
typedef JStatusTimes = ffi.Char;
typedef PGM_C_GET_TICKS
    = ffi.Pointer<ffi.NativeFunction<ffi.Uint64 Function()>>;
typedef JRelation = ffi.Char;
typedef JStrSet = ffi.Char;
typedef JMsgContent = ffi.Char;
