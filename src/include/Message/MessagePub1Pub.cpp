//
// *****************************************************************************
// Copyright(c) 2017-2022 Juphoon System Software Co., LTD. All rights reserved.
// *****************************************************************************
//
// Auto generated from: MessagePub1.def
// Warning: do not edit this file.
//

#include "Message/MessagePub1Pub.h"

namespace Message
{

MsgContent::MsgContent()
{
}

MsgContent::MsgContent(const Common::String& x__type,const Common::String& x__body,const Common::StrStreamMap& x__ress,const Common::StrStrMap& x__params) :
    _type(x__type),_body(x__body),_ress(x__ress),_params(x__params)
{
}

bool MsgContent::operator<(const MsgContent&__obj) const
{
    if (this == &__obj) return false;
    if (_type < __obj._type) return true;
    if (__obj._type < _type) return false;
    if (_body < __obj._body) return true;
    if (__obj._body < _body) return false;
    if (_ress < __obj._ress) return true;
    if (__obj._ress < _ress) return false;
    if (_params < __obj._params) return true;
    if (__obj._params < _params) return false;
    return false;
}

bool MsgContent::operator==(const MsgContent&__obj) const
{
    if (this == &__obj) return true;
    if (_type != __obj._type) return false;
    if (_body != __obj._body) return false;
    if (_ress != __obj._ress) return false;
    if (_params != __obj._params) return false;
    return true;
}

void MsgContent::__write(const Common::OputStreamPtr& __oput) const
{
    __write_MsgContent(__oput,*this);
}

void MsgContent::__read(const Common::IputStreamPtr& __iput)
{
    __read_MsgContent(__iput,*this);
}

void MsgContent::__textWrite(const Common::OputStreamPtr& __oput,const Common::String& __name) const
{
    __textWrite_MsgContent(__oput,__name,*this);
}

bool MsgContent::__textRead(const Common::IputStreamPtr& __iput,const Common::String& __name,int __idx)
{
    return __textRead_MsgContent(__iput,__name,*this,__idx);
}

void __write_MsgContent(const Common::OputStreamPtr& __oput,const Message::MsgContent& __obj)
{
    __oput->write(__obj._type);
    __oput->write(__obj._body);
    Common::__write_StrStreamMap(__oput,__obj._ress);
    Common::__write_StrStrMap(__oput,__obj._params);
}

void __read_MsgContent(const Common::IputStreamPtr& __iput,Message::MsgContent& __obj)
{
    __iput->read(__obj._type);
    __iput->read(__obj._body);
    Common::__read_StrStreamMap(__iput,__obj._ress);
    Common::__read_StrStrMap(__iput,__obj._params);
}

void __textWrite_MsgContent(const Common::OputStreamPtr& __oput,const Common::String& __name,const Message::MsgContent& __obj)
{
    __oput->textStart(__name);
    __oput->textWrite("_type",__obj._type);
    __oput->textWrite("_body",__obj._body);
    Common::__textWrite_StrStreamMap(__oput,"_ress",__obj._ress);
    Common::__textWrite_StrStrMap(__oput,"_params",__obj._params);
    __oput->textEnd();
}

bool __textRead_MsgContent(const Common::IputStreamPtr& __iput,const Common::String& __name,Message::MsgContent& __obj,int __idx)
{
    if (!__iput->textStart(__name,__idx)) return false;
    __iput->textRead("_type",__obj._type,0);
    __iput->textRead("_body",__obj._body,0);
    Common::__textRead_StrStreamMap(__iput,"_ress",__obj._ress,0);
    Common::__textRead_StrStrMap(__iput,"_params",__obj._params,0);
    __iput->textEnd();
    return true;
}

Msg::Msg() :
    _msgIdx((Common::Long)-1),
    _time((Common::Long)-1)
{
}

Msg::Msg(Common::Long x__msgIdx,Common::Long x__time,const Common::String& x__sender,const Message::MsgContent& x__content) :
    _msgIdx(x__msgIdx),_time(x__time),_sender(x__sender),_content(x__content)
{
}

bool Msg::operator<(const Msg&__obj) const
{
    if (this == &__obj) return false;
    if (_msgIdx < __obj._msgIdx) return true;
    if (__obj._msgIdx < _msgIdx) return false;
    if (_time < __obj._time) return true;
    if (__obj._time < _time) return false;
    if (_sender < __obj._sender) return true;
    if (__obj._sender < _sender) return false;
    if (_content < __obj._content) return true;
    if (__obj._content < _content) return false;
    return false;
}

bool Msg::operator==(const Msg&__obj) const
{
    if (this == &__obj) return true;
    if (_msgIdx != __obj._msgIdx) return false;
    if (_time != __obj._time) return false;
    if (_sender != __obj._sender) return false;
    if (_content != __obj._content) return false;
    return true;
}

void Msg::__write(const Common::OputStreamPtr& __oput) const
{
    __write_Msg(__oput,*this);
}

void Msg::__read(const Common::IputStreamPtr& __iput)
{
    __read_Msg(__iput,*this);
}

void Msg::__textWrite(const Common::OputStreamPtr& __oput,const Common::String& __name) const
{
    __textWrite_Msg(__oput,__name,*this);
}

bool Msg::__textRead(const Common::IputStreamPtr& __iput,const Common::String& __name,int __idx)
{
    return __textRead_Msg(__iput,__name,*this,__idx);
}

void __write_Msg(const Common::OputStreamPtr& __oput,const Message::Msg& __obj)
{
    __oput->write(__obj._msgIdx);
    __oput->write(__obj._time);
    __oput->write(__obj._sender);
    Message::__write_MsgContent(__oput,__obj._content);
}

void __read_Msg(const Common::IputStreamPtr& __iput,Message::Msg& __obj)
{
    __iput->read(__obj._msgIdx);
    __iput->read(__obj._time);
    __iput->read(__obj._sender);
    Message::__read_MsgContent(__iput,__obj._content);
}

void __textWrite_Msg(const Common::OputStreamPtr& __oput,const Common::String& __name,const Message::Msg& __obj)
{
    __oput->textStart(__name);
    __oput->textWrite("_msgIdx",__obj._msgIdx);
    __oput->textWrite("_time",__obj._time);
    __oput->textWrite("_sender",__obj._sender);
    Message::__textWrite_MsgContent(__oput,"_content",__obj._content);
    __oput->textEnd();
}

bool __textRead_Msg(const Common::IputStreamPtr& __iput,const Common::String& __name,Message::Msg& __obj,int __idx)
{
    if (!__iput->textStart(__name,__idx)) return false;
    __iput->textRead("_msgIdx",__obj._msgIdx,0);
    __iput->textRead("_time",__obj._time,0);
    __iput->textRead("_sender",__obj._sender,0);
    Message::__textRead_MsgContent(__iput,"_content",__obj._content,0);
    __iput->textEnd();
    return true;
}
void __write_SortedMsgs(const Common::OputStreamPtr& __oput,const Message::SortedMsgs& __obj)
{
    __oput->write((int)__obj.size());
    vector<Message::Msg>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Message::__write_Msg(__oput,*it1);
}

void __read_SortedMsgs(const Common::IputStreamPtr& __iput,Message::SortedMsgs& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Message::Msg m;
        Message::__read_Msg(__iput,m);
        __obj.push_back(m);
    }
}

void __textWrite_SortedMsgs(const Common::OputStreamPtr& __oput,const Common::String& __name,const Message::SortedMsgs& __obj)
{
    __oput->textArray(__name);
    vector<Message::Msg>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Message::__textWrite_Msg(__oput,__name,*it1);
}

bool __textRead_SortedMsgs(const Common::IputStreamPtr& __iput,const Common::String& __name,Message::SortedMsgs& __obj)
{
    __obj.clear();
    int size = __iput->textCount(__name);
    for (int i=0;i<size;i++)
    {
        Message::Msg m;
        if (Message::__textRead_Msg(__iput,__name,m,i))
            __obj.push_back(m);
    }
    return true;
}

void __write_SortedMsgss(const Common::OputStreamPtr& __oput,const Message::SortedMsgss& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Message::SortedMsgs>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        Message::__write_SortedMsgs(__oput,it1->second);
    }
}

void __read_SortedMsgss(const Common::IputStreamPtr& __iput,Message::SortedMsgss& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Message::SortedMsgs v;
        __iput->read(k);
        Message::__read_SortedMsgs(__iput,v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_SortedMsgss(const Common::OputStreamPtr& __oput,const Common::String& __name,const Message::SortedMsgss& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Message::SortedMsgs>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Message::__textWrite_SortedMsgs(__oput,it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_SortedMsgss(const Common::IputStreamPtr& __iput,const Common::String& __name,Message::SortedMsgss& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Message::SortedMsgs v;
            if (Message::__textRead_SortedMsgs(__iput,*it1,v))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}


};//namespace: Message
