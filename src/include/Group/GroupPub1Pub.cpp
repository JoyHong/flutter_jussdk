//
// *****************************************************************************
// Copyright(c) 2017-2022 Juphoon System Software Co., LTD. All rights reserved.
// *****************************************************************************
//
// Auto generated from: GroupPub1.def
// Warning: do not edit this file.
//

#include "Group/GroupPub1Pub.h"

namespace Group
{
const char* RelationType_toString(Group::RelationType val)
{
    switch (val)
    {
    case Owner: return (const char *)"Owner";
    case Manager: return (const char *)"Manager";
    case Member: return (const char *)"Member";
    case ExMember: return (const char *)"ExMember";
    case OrgEnd: return (const char *)"OrgEnd";
    case Organize: return (const char *)"Organize";
    case CloseFriend: return (const char *)"CloseFriend";
    case Friend: return (const char *)"Friend";
    case Contact: return (const char *)"Contact";
    case Follow: return (const char *)"Follow";
    case Stranger: return (const char *)"Stranger";
    case Blacklist: return (const char *)"Blacklist";
    case System: return (const char *)"System";
    case PersonEnd: return (const char *)"PersonEnd";
    case NullType: return (const char *)"NullType";
    case NoneSyncType: return (const char *)"NoneSyncType";
    default: return (const char *)"unknown";
    }
}

Relation::Relation() :
    type(Group::NullType)
{
}

Relation::Relation(Group::RelationType x_type,const Common::String& x_tagName,const Common::String& x_tag,const Common::StrStrMap& x_cfgs) :
    type(x_type),tagName(x_tagName),tag(x_tag),cfgs(x_cfgs)
{
}

bool Relation::operator<(const Relation&__obj) const
{
    if (this == &__obj) return false;
    if (type < __obj.type) return true;
    if (__obj.type < type) return false;
    if (tagName < __obj.tagName) return true;
    if (__obj.tagName < tagName) return false;
    if (tag < __obj.tag) return true;
    if (__obj.tag < tag) return false;
    if (cfgs < __obj.cfgs) return true;
    if (__obj.cfgs < cfgs) return false;
    return false;
}

bool Relation::operator==(const Relation&__obj) const
{
    if (this == &__obj) return true;
    if (type != __obj.type) return false;
    if (tagName != __obj.tagName) return false;
    if (tag != __obj.tag) return false;
    if (cfgs != __obj.cfgs) return false;
    return true;
}

void Relation::__write(const Common::OputStreamPtr& __oput) const
{
    __write_Relation(__oput,*this);
}

void Relation::__read(const Common::IputStreamPtr& __iput)
{
    __read_Relation(__iput,*this);
}

void Relation::__textWrite(const Common::OputStreamPtr& __oput,const Common::String& __name) const
{
    __textWrite_Relation(__oput,__name,*this);
}

bool Relation::__textRead(const Common::IputStreamPtr& __iput,const Common::String& __name,int __idx)
{
    return __textRead_Relation(__iput,__name,*this,__idx);
}

void __write_Relation(const Common::OputStreamPtr& __oput,const Group::Relation& __obj)
{
    __oput->write((int)__obj.type);
    __oput->write(__obj.tagName);
    __oput->write(__obj.tag);
    Common::__write_StrStrMap(__oput,__obj.cfgs);
}

void __read_Relation(const Common::IputStreamPtr& __iput,Group::Relation& __obj)
{
    __iput->read((int&)__obj.type);
    __iput->read(__obj.tagName);
    __iput->read(__obj.tag);
    Common::__read_StrStrMap(__iput,__obj.cfgs);
}

void __textWrite_Relation(const Common::OputStreamPtr& __oput,const Common::String& __name,const Group::Relation& __obj)
{
    __oput->textStart(__name);
    __oput->textWrite("type",(int)__obj.type);
    __oput->textWrite("tagName",__obj.tagName);
    __oput->textWrite("tag",__obj.tag);
    Common::__textWrite_StrStrMap(__oput,"cfgs",__obj.cfgs);
    __oput->textEnd();
}

bool __textRead_Relation(const Common::IputStreamPtr& __iput,const Common::String& __name,Group::Relation& __obj,int __idx)
{
    if (!__iput->textStart(__name,__idx)) return false;
    __iput->textRead("type",(int&)__obj.type,0);
    __iput->textRead("tagName",__obj.tagName,0);
    __iput->textRead("tag",__obj.tag,0);
    Common::__textRead_StrStrMap(__iput,"cfgs",__obj.cfgs,0);
    __iput->textEnd();
    return true;
}
void __write_RelationsMap(const Common::OputStreamPtr& __oput,const Group::RelationsMap& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Group::Relation>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        Group::__write_Relation(__oput,it1->second);
    }
}

void __read_RelationsMap(const Common::IputStreamPtr& __iput,Group::RelationsMap& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Group::Relation v;
        __iput->read(k);
        Group::__read_Relation(__iput,v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_RelationsMap(const Common::OputStreamPtr& __oput,const Common::String& __name,const Group::RelationsMap& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Group::Relation>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Group::__textWrite_Relation(__oput,it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_RelationsMap(const Common::IputStreamPtr& __iput,const Common::String& __name,Group::RelationsMap& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Group::Relation v;
            if (Group::__textRead_Relation(__iput,*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}

void __write_ContactsMap(const Common::OputStreamPtr& __oput,const Group::ContactsMap& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Common::String>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        __oput->write(it1->second);
    }
}

void __read_ContactsMap(const Common::IputStreamPtr& __iput,Group::ContactsMap& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Common::String v;
        __iput->read(k);
        __iput->read(v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_ContactsMap(const Common::OputStreamPtr& __oput,const Common::String& __name,const Group::ContactsMap& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Common::String>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        __oput->textWrite(it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_ContactsMap(const Common::IputStreamPtr& __iput,const Common::String& __name,Group::ContactsMap& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Common::String v;
            if (__iput->textRead(*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}


};//namespace: Group
