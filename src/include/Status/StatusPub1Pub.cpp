//
// *****************************************************************************
// Copyright(c) 2017-2022 Juphoon System Software Co., LTD. All rights reserved.
// *****************************************************************************
//
// Auto generated from: StatusPub1.def
// Warning: do not edit this file.
//

#include "Status/StatusPub1Pub.h"

namespace Status
{
void __write_Statuses(const Common::OputStreamPtr& __oput,const Status::Statuses& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Common::String>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        __oput->write(it1->second);
    }
}

void __read_Statuses(const Common::IputStreamPtr& __iput,Status::Statuses& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Common::String v;
        __iput->read(k);
        __iput->read(v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_Statuses(const Common::OputStreamPtr& __oput,const Common::String& __name,const Status::Statuses& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Common::String>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        __oput->textWrite(it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_Statuses(const Common::IputStreamPtr& __iput,const Common::String& __name,Status::Statuses& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Common::String v;
            if (__iput->textRead(*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}

void __write_StatusesMap(const Common::OputStreamPtr& __oput,const Status::StatusesMap& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Status::Statuses>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        Status::__write_Statuses(__oput,it1->second);
    }
}

void __read_StatusesMap(const Common::IputStreamPtr& __iput,Status::StatusesMap& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Status::Statuses v;
        __iput->read(k);
        Status::__read_Statuses(__iput,v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_StatusesMap(const Common::OputStreamPtr& __oput,const Common::String& __name,const Status::StatusesMap& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Status::Statuses>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Status::__textWrite_Statuses(__oput,it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_StatusesMap(const Common::IputStreamPtr& __iput,const Common::String& __name,Status::StatusesMap& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Status::Statuses v;
            if (Status::__textRead_Statuses(__iput,*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}


StatusTime::StatusTime() :
    _time((Common::Long)-1)
{
}

StatusTime::StatusTime(const Common::String& x__value,Common::Long x__time) :
    _value(x__value),_time(x__time)
{
}

bool StatusTime::operator<(const StatusTime&__obj) const
{
    if (this == &__obj) return false;
    if (_value < __obj._value) return true;
    if (__obj._value < _value) return false;
    if (_time < __obj._time) return true;
    if (__obj._time < _time) return false;
    return false;
}

bool StatusTime::operator==(const StatusTime&__obj) const
{
    if (this == &__obj) return true;
    if (_value != __obj._value) return false;
    if (_time != __obj._time) return false;
    return true;
}

void StatusTime::__write(const Common::OputStreamPtr& __oput) const
{
    __write_StatusTime(__oput,*this);
}

void StatusTime::__read(const Common::IputStreamPtr& __iput)
{
    __read_StatusTime(__iput,*this);
}

void StatusTime::__textWrite(const Common::OputStreamPtr& __oput,const Common::String& __name) const
{
    __textWrite_StatusTime(__oput,__name,*this);
}

bool StatusTime::__textRead(const Common::IputStreamPtr& __iput,const Common::String& __name,int __idx)
{
    return __textRead_StatusTime(__iput,__name,*this,__idx);
}

void __write_StatusTime(const Common::OputStreamPtr& __oput,const Status::StatusTime& __obj)
{
    __oput->write(__obj._value);
    __oput->write(__obj._time);
}

void __read_StatusTime(const Common::IputStreamPtr& __iput,Status::StatusTime& __obj)
{
    __iput->read(__obj._value);
    __iput->read(__obj._time);
}

void __textWrite_StatusTime(const Common::OputStreamPtr& __oput,const Common::String& __name,const Status::StatusTime& __obj)
{
    __oput->textStart(__name);
    __oput->textWrite("_value",__obj._value);
    __oput->textWrite("_time",__obj._time);
    __oput->textEnd();
}

bool __textRead_StatusTime(const Common::IputStreamPtr& __iput,const Common::String& __name,Status::StatusTime& __obj,int __idx)
{
    if (!__iput->textStart(__name,__idx)) return false;
    __iput->textRead("_value",__obj._value,0);
    __iput->textRead("_time",__obj._time,0);
    __iput->textEnd();
    return true;
}
void __write_StatusTimes(const Common::OputStreamPtr& __oput,const Status::StatusTimes& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Status::StatusTime>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        Status::__write_StatusTime(__oput,it1->second);
    }
}

void __read_StatusTimes(const Common::IputStreamPtr& __iput,Status::StatusTimes& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Status::StatusTime v;
        __iput->read(k);
        Status::__read_StatusTime(__iput,v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_StatusTimes(const Common::OputStreamPtr& __oput,const Common::String& __name,const Status::StatusTimes& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Status::StatusTime>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Status::__textWrite_StatusTime(__oput,it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_StatusTimes(const Common::IputStreamPtr& __iput,const Common::String& __name,Status::StatusTimes& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Status::StatusTime v;
            if (Status::__textRead_StatusTime(__iput,*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}

void __write_StatusVersMap(const Common::OputStreamPtr& __oput,const Status::StatusVersMap& __obj)
{
    __oput->write((int)__obj.size());
    map<Common::String,Status::StatusTimes>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
    {
        __oput->write(it1->first);
        Status::__write_StatusTimes(__oput,it1->second);
    }
}

void __read_StatusVersMap(const Common::IputStreamPtr& __iput,Status::StatusVersMap& __obj)
{
    __obj.clear();
    int size;__iput->read(size);
    for (int i=0;i< size;i++)
    {
        Common::String k;Status::StatusTimes v;
        __iput->read(k);
        Status::__read_StatusTimes(__iput,v);
        __obj.insert(make_pair(k,v));
    }
}

void __textWrite_StatusVersMap(const Common::OputStreamPtr& __oput,const Common::String& __name,const Status::StatusVersMap& __obj)
{
    __oput->textStart(__name);
    map<Common::String,Status::StatusTimes>::const_iterator it1;
    for (it1 = __obj.begin();it1 != __obj.end();it1++)
        Status::__textWrite_StatusTimes(__oput,it1->first,it1->second);
    __oput->textEnd();
}

bool __textRead_StatusVersMap(const Common::IputStreamPtr& __iput,const Common::String& __name,Status::StatusVersMap& __obj,int __idx)
{
    __obj.clear();
    if (__iput->textStart(__name,__idx))
    {
        set<Common::String> ks;
        set<Common::String>::iterator it1;
        __iput->textList(ks);
        for (it1 = ks.begin();it1 != ks.end();it1++)
        {
            Status::StatusTimes v;
            if (Status::__textRead_StatusTimes(__iput,*it1,v,0))
                __obj.insert(make_pair(*it1,v));
        }
        __iput->textEnd();
    }
    return true;
}


};//namespace: Status
